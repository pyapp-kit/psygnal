from __future__ import annotations

import textwrap
from itertools import product
from pathlib import Path
from typing import NamedTuple

import black
import black.mode

ARG0 = "obj"
FINALIZER = "finalizer"
REF_ERROR = "ReferenceError('weakly-referenced callback no longer exists')"


class ClassInfo(NamedTuple):
    """Info needed to make all permutations of callback classes."""

    base_name: str
    obj_type: str
    init_lines: list[str]
    get_func: list[str]
    extra_args: list[str] = []


StrongFunc = ClassInfo(
    base_name="_StrongFunction",
    obj_type="FunctionType",
    init_lines=[f"self._func = {ARG0}"],
    get_func=["func = self._func"],
)
WeakFunc = ClassInfo(
    base_name="_WeakFunction",
    obj_type="FunctionType",
    init_lines=[f"self._ref = self._try_ref({ARG0}, {FINALIZER})"],
    get_func=[
        "func = self._ref()",
        f"if func is None: raise {REF_ERROR}",
    ],
)
WeakMethod = ClassInfo(
    base_name="_WeakMethod",
    obj_type="MethodType",
    init_lines=[
        f"self._obj_ref = self._try_ref({ARG0}.__self__, {FINALIZER})",
        f"self._func_ref = self._try_ref({ARG0}.__func__, {FINALIZER})",
    ],
    get_func=[
        "obj = self._obj_ref()",
        "func = self._func_ref()",
        f"if obj is None or func is None: raise {REF_ERROR}",
    ],
    extra_args=["obj"],
)
WeakBuiltin = ClassInfo(
    base_name="_WeakBuiltin",
    obj_type=" MethodWrapperType | BuiltinMethodType",
    init_lines=[
        f"self._obj_ref = self._try_ref({ARG0}.__self__, {FINALIZER})",
        f"self._func_name = {ARG0}.__name__",
    ],
    get_func=[
        "obj = self._obj_ref()",
        "func = getattr(obj, self._func_name, None)",
        f"if func is None: raise {REF_ERROR}",
    ],
)


def _build_class(
    info: ClassInfo,
    args: bool,
    clipped: bool,
    kwargs: bool,
) -> str:
    base_name = info.base_name
    if args:
        base_name += "Args"
    if clipped:
        base_name += "Clipped"
    if kwargs:
        base_name += "Kwargs"

    init = f"    def __init__(self, {ARG0}: {info.obj_type}"
    if args:
        init += ", *args: Any"
    if clipped:
        init += ", max_args: int"
    if "strong" not in base_name.lower():
        init += f", {FINALIZER}: Callable[[WeakCallback], Any] | None = None"
    if kwargs:
        init += ", **kwargs: Any"
    init.rstrip(", ")
    init += ") -> None:"

    lines = [
        f"class {base_name}(WeakCallback):",
        init,
        f"        super().__init__({ARG0})",
        *[textwrap.indent(x, " " * 8) for x in info.init_lines],
    ]
    if args:
        lines.append("        self._args = args")
    if clipped:
        lines.append("        self._max_args = max_args")
    if kwargs:
        lines.append("        self._kwargs = kwargs")

    lines.extend(("", "    def cb(self, args: tuple[Any, ...]) -> None:"))
    lines.extend([textwrap.indent(x, " " * 8) for x in info.get_func])
    call = "func("
    if info.extra_args:
        call += ", ".join(info.extra_args) + ", "
    if args:
        call += "*self._args, "
    call += "*args[: self._max_args]" if clipped else "*args"
    if kwargs:
        call += ", **self._kwargs"
    call.rstrip(", ")
    call += ")"
    lines.append(f"        {call}")

    src = "\n".join(lines)
    return black.format_str(src, mode=black.mode.Mode())  # type: ignore


def main(dest: str | Path) -> None:
    """Update the code in the given file with all the callback classes."""
    original_text = Path(dest).read_text()
    out = original_text.split("# START_AUTOGENERATED_CODE")[0]
    out += "# START_AUTOGENERATED_CODE\n\n"
    for info in [StrongFunc, WeakFunc, WeakMethod, WeakBuiltin]:
        for arg, clip, kwarg in product([False, True], [False, True], [False, True]):
            out += _build_class(info, arg, clip, kwarg) + "\n\n"

    out = black.format_str(out, mode=black.mode.Mode())
    Path(dest).write_text(out)
    print("Updated", dest)


if __name__ == "__main__":
    import sys

    if len(sys.argv) > 1:
        main(sys.argv[1])
    else:
        main("src/psygnal/_weak_callback.py")
